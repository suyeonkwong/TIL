- 알고리즘
  - https://school.programmers.co.kr/learn/courses/30/lessons/131701
- 공부내용
    <details>
    <summary>자바의 jvm에서 이루어지는 gc에대해 설명</summary>
    <div markdown="1">       
    GC란 동적으로 할당된 메모리 영역 중 사용하지 않는 영역을 해지하는 메모리 기법이다. 자바에서는 JVM의 heap영역의 객체들이 GC의 대상이 된다. 
    jvm은 RootSpace부터 그래프 순회를 통해 연결된 객체를 찾아내는 mark과정과 연결이 끊어진 객체를 지우는 sweep과정과 분산되어 있던 메모리를 정리해서 메모리 파편화를 방지하     는 compact과정으로 GC를 실행한다. GC도 작업이기 때문에 애플리케이션의 사용성을 유지하면서 효율적으로 GC를 실행해야 하는 것이 중요하다. 
    heap은 young과 old영역으로 이루어져있는데 이것은 객체의 생명 주기가 짧기 때문에 GC수행을 메모리 전체 부분이 아니라 특정 부분만 탐색하고 해제해야 효율적이므로 최대한       young영역에서 메모리를 해제하도록 설계한 것이다. young 영역은 한개의 eden영역과 두개의 survivor영역으로 이루어져있다. 새로 생성된 객체들은 eden영역에 위치하게 되고       eden이 가득차게 될 경우 GC가 발생하게 된다. 이때 eden에서 참조되지 않는 객체의 메모리는 해제되며 살아남은 객체들이 두개의 survivor영역중 한 곳으로 이동한다. 그리고 한     곳의 survivor가 가득차면 살아남은 객체들의 age값이 증가되고 비어있는 다른 survivor영역으로 이동하며 원래 사용되던 survivor영역은 비워진다. 이러한 과정이 계속해서 반복     되면서 살아남은 객체의 age값이 특정 임계치 값이 되면 old영역으로 promotion된다. 
    </div>
    </details> 
    <details>
    <summary>자바에서 발생하는 동시성 문제를 해결하기 위한 방법
    </summary>
    <div markdown="1">       
    상태를 가지지 않는 불변객체를 사용
    Synchronized : 영역 전체에 lock을 걸기 때문에 실행중인 스레드 외에 다른 스레드들은 블로킹 상태가 되므로 아무런 작업을 수행하지 못하고 기다려서 자원의 낭비가 발생한다.
    volatile : 캐싱된 값이 아니라 메인메모리에서 값을 참조할 수 있도록 하여 동일 시점에 동일한 값을 가지도록 동기화 한다. 변수 앞에 붙이는 키워드이다. ++처럼 원자성이 보장되지 않는 경우 동시성 문제가 발생하며 모든 스레드가 캐시 없이 최신의 값을 보이게 하는 것이다.
    Atomic : 논블로킹이여도 동시성을 보장하는 이유는 CAS알고리즘 때문인데 volatile을 이용하면서 현재 스레드의 저장된 값과 메인 메모리에 저장된 값을 비교하여 일치하는 경우 새로운 값으로 교체하고 일치하지 않는 경우 재시도 한다. volatile은 한개의 스레드에서 쓰기작업을 하고 다른 스레드는 읽기작업을 할때 사용하고 Atomic은 여러 스레드에서 읽기와 쓰기를 병행한다. 
    </div>
    </details>
    <details>
    <summary>스프링 시큐리티가 인터셉터를 사용하지 않고 필터를 사용한 이유</summary>
    <div markdown="1">       
    정확히 말하면 서블릿 필터체인 기반으로 동작하는데 필터는 디스패처 서블릿 전에 실행되므로 스프링 영역과 무관하게 실행된다. 만약 요청이 프론트컨트롤러인 디스패처 서블릿까지 와서 컨트롤러로 위임이 된다면 인증관련 처리를 여러 곳에서 해야하기 때문인가? 
    </div>
    </details>
