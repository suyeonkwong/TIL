 <details>
<summary>spring</summary>
<div markdown="1">
 
 + 스프링이란
    + 자바의 큰 특징인 객체지향 언어가 가진 강력한 특징을 살리고 좋은 객체지향 어플리케이션을 개발할 수 있게 도와주는 프레임워크이다.

 + 스프링이 객체지향이라고 표현되는 이유
    + 스프링은 OCP와 DIP를 통해 객체지향의 핵심인 다형성을 지키고 있는데 DI컨테이너를 통해 의존성을 주입함으로써 구현체를 언제든지 유연하게 변경할 수 있도록 한다.

 + 스프링 장 단점
    + 장점 : 코드를 개발할때 특정한 라이브러리나 컨테이너에 기술에 종속이지 않고 자바 코드를 이용해서 객체를 구성하는 방식을 그대로 스프링에서 사용할 수 있는 POJO기반의 구성이다. DI컨테이너가 객체의 생성과 의존관계 주입을 대신 해주기때문에 개발자는 역할 구현에만 신경쓰면 된다. 보안이나 로그, 트랜잭션과 같은 횡단 관심사를 모듈로 분리하는 AOP 관점지향 프로그래밍을 통해 반복적인 코드를 줄이고 핵심 비지니스 로직에 집중 할 수 있다. 

 + 스프링부트의 메인 메서드를 실행하는 곳에붙어있는 스프링부트애플리케이션 어노테이션에 대해 설명해라. 스프링부트가 돌아가기 위해서 정확히는 컨테이너가 돌아가기 위해서 스프링부트의 컨테이너가 실행되기 전까지 어떤 진행과정을 거치냐
    + 스프링부트애플리케이션 어노테이션은 내부적으로 @SpringBootConfiguration, @EnableAutoConfiguration, @ComponentScan 세가지 어노테이션을 가지고 있으며 자동설정 및 Bean읽기와 생성을 자동으로 한다.
    + @ComponentScan : 하위 패키지들을 스캔하여 @Component가 선언된 클래스들을 찾아 Bean으로 등록하는 역할을한다. 
    + @EnableAutoConfiguration : 스프링부트의 Application Context 설정을 자동으로 수행한다는 어노테이션으로 AopAutoConfiguration, BatchAutoConfiguration, CacheAutoConfiguration등 class 내부에 정의된 여러 라이브러리 클래스들을 자동으로 찾아 Bean으로 등록한다. 설정값을 추가하지 않으면 기본값으로 작동한다.
    + @SpringBootConfiguration :  @Configuration과 동일한 역할이며 해당 어노테이션이 붙은 클래스가 하나 이상의 @Bean메서드를 선언하여 사용자가 추가적으로 빈이나 설정 클래스들을 등록하게 한다. 


 + 스프링부트와 스프링의 차이점중에 설정을 자동으로 해주는 부분에 대한 어노테이션에 대한 질문
    + @EnableAutoConfiguration

 + 스프링 mvc가 뭐냐
    + Spring MVC는 Spring에서 제공하는 모듈로 Model, View, Controller 세 가지 구성 요소를 통해 요청을 처리하고 단순한 텍스트 응답이나 REST형식의 응답은 물론 화면을 표시하는 html을 return하는 다양한 응답 형식을 제공하는 모듈이다. 주요 구성 요소는 Model, View, Controller이지만 프론트 컨트롤러인 DispatcherServlet을 통해 가장 앞에서 Http 요청을 받게하고 HandlerMapping을 통해 해당 요청을 처리할 Controller에게 요청을 위임하고 처리된 요청을 뷰 리졸버를 통해 응답 결과를 생성할 View를 찾아 최종적으로 클라이언트에게 화면을 제공한다.


 + 스프링 시큐리티에서 인증 인가 처리시 필터체인에 대해 설명해라
    + 스프링 시큐리티는 메인 필터들 사이에 시큐리티 필터 체인을 그룹화 시켜 그룹에 속한 필터들을 url에 따라 적용 여부를 판단하여 요청이 해당 필터들을 거쳐 최종적으로 서블릿에 도달하는 구조이다. 

 + 기억에 남는 필터에 대해, 해당 필터가 어떤 동작을 하는지
    + UsernamePasswordAuthenticationFilter : Username과 password기반의 인증과정을 거치며 인증 성공 시 Authentication객체를 SecurityContext에 저장하는 필터이다.
BasicAuthenticationFilter : 요청 헤더 값을 읽어와 SecurityContextHolder에 저장하여 매번 요청마다 인증을 시도하므로 stateless하다는 특징이 있다.
</div>
</details>

<details>
<summary>jpa</summary>
<div markdown="1">
 
 + jdbc나 myBatis를 사용하지 않고 jpa를 사용한 이유
    + jpa는 자바 진영의 ORM 기술 표준으로 객체와 관계를 매핑하는 ORM을 통해 객체는 객체대로 설계하고 관계형 데이터베이스는 관계형 데이터베이스 대로 설계할 수 있게 하여 기존 myBatis의 쿼리 매핑 코드를 작성하지 않고도 기본적인 CRUD나 페이징 처리같은 미리 구현되어있는 코드가 많아 비지니스로직에 집중 할 수 있으며 RDB종류에 관계없이 사용이 가능하기 때문에 DB변경이 있어도 코드 재사용이 가능하다.

 + entity매니저에 대해 설명해라
    + jpa는 엔티티를 영구 저장하는 환경인 영속성 컨텍스트가 있는데 엔티티 매니저를 통해 영속성 컨텍스트에 조회, 저장하여 영속성 컨텍스트에 엔티티를 보관하고 관리한다. 
    + 1차캐시 : 영속성 컨텍스트 내부에는 1차 캐시가 있는데 영속성 컨텍스트 내부에 엔티티가 있는 상태를 영속 상태라고 하며 영속 상태일때 조회 시 해당 엔티티를 DB에서 읽는 것이 아니라 영속성 컨텍스트 내부에 있는 1차캐시에서 값을 읽어온다. 
    + 동일성 보장 : 같은 트랜잭션 안에서 같은 객체를 비교하면 동일성을 보장한다.
    + 쓰기 지연 : 영속성 컨텍스트 내부에는 쓰기지연 저장소가 있는데 엔티티를 생성하고 persist(저장) 하게 되면 내부적으로 쓰기지연 저장소에 저장이 되어있다가 트랜잭션이 커밋되는 시점에 쓰기지연 저장소에 있던 쿼리가 DB에 반영된다.
    + 변경 감지 : 엔티티의 값을 변경하고 저장하지 않아도, 트랜잭션을 커밋하는 시점에 처음 엔티티가 영속성 컨텍스트에 들어온 상태를 보관하는 1차 캐시의 스냅샷과 엔티티를 비교하여 변경 사항이 있을 경우 update쿼리를 만들어 쓰기지연 저장소에 저장하고 커밋되면 실제 update쿼리가 DB에 날아간다.
</div>
</details>

<details>
<summary>mysql</summary>
<div markdown="1">
 
 + mysql의 엔진구조에 대해 설명해라
    + mysql서버는 mysql엔진과 스토리지 엔진으로 이루어진다. mysql엔진은 클라이언트로부터의 접속 및 쿼리 요청을 담당하는 커넥션 핸들러와 SQL파서, 전처리기 그리고 쿼리의 최적화된 실행을 위한 옵티마이저로 이루어져있다. 쿼리문장을 분석하거나 최적화 하는 기능은 mysql엔진이 해결하지만 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 담당한다.

 + 스토리지 엔진에 대한 설명과 어떤 종류가 있는지
    + 스토리지 엔진은 여러 종류가 있는데 크게 MyISAM과 InnoDB이 있으며 실제 데이터를 디스크에 저장하거나 디스크에 있는 데이터를 읽어오는 역할을 한다. 
  
 + 이노디비의 특징이 뭐냐
    + 클러스터링 인덱스 : 이노디비의 모든 테이블은 프라이머리키를 기준으로 클러스터링 되어 저장된다. 모든 인덱스는 레코드 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용하며 프라이머리 키 기반의 검색이 매우 빠르다. 
    + 외래키 지원
    + MVCC : 레코드 레벨의 트랜잭션을 지원하기 때문에 하나의 레코드에 대해 여러 개의 버전이 동시에 관리되며 언두로그를 통해 잠금 없는 일관된 읽기를 제공한다. 트랜잭션 격리 수준을 보장하기 위해 변경되기 전의 데이터를 백업하고 이것을 언두로그에 저장한다. 
    + 버퍼 풀 : 버퍼풀은 데이터베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 기능을 제공한다.

 +  트랜잭션을 사용할때 여러가지 격리레벨을 지원하는데 격리레벨 네가지에 대한 종류와 어떤 식으로 동작하는지 각 격리 레벨에서 발생하는 문제점이 뭔지에 대해 설명해라
    + 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.
    + READ UNCOMMITTED : 커밋되지 않은 결과도 다른 트랜잭션에서 볼 수 있기 때문에 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상인 더티리드가 발생한다. 
    + READ COMMITTED : 커밋된 데이터를 언두로그에서 읽기때문에 하나의 트랜잭션 내에서 똑같은 SELECT쿼리를 실행했을 때 항상 같은 결과를 가져와야 하는 NON-REPEATABLE READ문제가 발생한다.
    + REPEATABLE READ : 자신의 트랜잭션 번호보다 큰 트랜잭션 번호에서 변경된 데이터는 언두로그에서 읽기 때문에 NON REPEATABLE READ문제점을 해결할 수 있다. 그러나 SELECT FOR UPDATE는 SELECT하는 레코드에 쓰기 잠금을 걸어야 하는데 언두 레코드에는 잠금을 걸 수 없으므로 조회되는 레코드를 언두 영역이 아니라 현재 레코드의 값을 가져오게 된다. 한 트랜잭션 안에서 일정 범위의 레코드를 두번 읽을때 첫번째 쿼리에서 없었던 유령 레코드가 두번째 쿼리에서 나타나는 현상을 PHANTOM READ라고 하는데 이노디비는 넥스트키락을 통해 레코드 삽입이 불가능하므로 PHANTOM READ의 문제점을 해결한다. 
    + SERIALIZABLE : 가장 엄격한 격리수준이며 읽기 작업도 공유잠금을 획득해야 하기때문에 다른 트랜잭션이 쓰기도 할 수 없다. 이노디비의 특징인 잠금이 필요없는 일관된 읽기를 사용할 수 없으며 동시처리 성능이 매우 떨어진다.


 + 공유락과 쓰기락 알고 있냐?
    + 락은 공유데이터 접근에 대한 순차성을 보장한다.
    + 공유락 : 데이터를 읽기 할때 사용하는 락으로 READ LOCK끼리는 동시 접근이 가능한데 쓰기락의 접근을 막는다. 
    + 쓰기락 : 쓰기락이 끝나기 전까지 어떠한 접근도 허용하지 않으며 다른 트랜잭션이 읽거나 수정할 수 없다.  공유락에 대해서도 배타적이다. 
</div>
</details>

<details>
<summary>cs</summary>
<div markdown="1">
 
 + 프로세스와 쓰레드의 차이점
    + 프로세스와 스레드는 작동방식에 차이가 있다. 프로세스는 메모리에 올라갈때 운영체제의 자원을 할당받는데 이 때 운영체제는 프로세스마다 각각 독립된 영역을 Code, Data, Stack, Heap 형식으로 할당한다. 각각 독립된 영역을 할당받기 때문에 프로세스는 다른 프로세스의 데이터에 접근할 수 없다. 그러나 스레드는 한 프로세스 내부에서  여러 쓰레드가 Stack을 제외한 나머지 Code, Data, Heap영역을 공유하기 때문에 작업전환 시 공유 메모리에 대한 자원을 절약할 수 있다. 

 + TCP와 UDP의 차이점
    + TCP는 가상회선방식 패킷교환방식을 통해 주고받는 데이터의 순서를 보장하며 연결지향형 프로토콜이다. UDP는 데이터그램 패킷교환방식으로 비연결형 프로토콜이다. 
 
</div>
</details>
